#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'docscribe/config'

options = {
  stdin: false,
  write: false,
  check: false,
  rewrite: false,
  config: nil,
  include: [], # method include patterns
  exclude: [], # method exclude patterns
  include_file: [], # file include patterns
  exclude_file: [] # file exclude patterns
}

def looks_like_file_pattern?(pat)
  pat.include?('/') || pat.include?('**') || pat.end_with?('.rb')
end

if ARGV.first == 'init'
  ARGV.shift

  init_options = {
    config: 'docscribe.yml',
    force: false,
    stdout: false
  }

  OptionParser.new do |opts|
    opts.banner = 'Usage: docscribe init [options]'
    opts.on('--config PATH', 'Where to write the config (default: docscribe.yml)') { |v| init_options[:config] = v }
    opts.on('-f', '--force', 'Overwrite if the file already exists') { init_options[:force] = true }
    opts.on('--stdout', 'Print config template to STDOUT instead of writing a file') { init_options[:stdout] = true }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end.parse!(ARGV)

  yaml = Docscribe::Config.default_yaml

  if init_options[:stdout]
    puts yaml
    exit 0
  end

  path = init_options[:config]
  if File.exist?(path) && !init_options[:force]
    warn "Config already exists: #{path} (use --force to overwrite)"
    exit 1
  end

  File.write(path, yaml)
  puts "Created: #{path}"
  exit 0
end

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: docscribe [options] [files...]'
  opts.on('-d', '-c', '--dry', '--check', 'Dry-run: exit 1 if any file would change') { options[:check] = true }
  opts.on('-w', '--write', 'Rewrite files in place') { options[:write] = true }
  opts.on('-r', '--refresh', 'Replace existing comment blocks above methods') { options[:refresh] = true }
  opts.on('--stdin', 'Read code from STDIN and print with docs inserted') { options[:stdin] = true }
  opts.on('-C', '--config PATH', 'Path to config YAML (default: docscribe.yml)') { |v| options[:config] = v }
  # Method filters (glob or /regex/) â€” but if it looks like a file/path, route to file filters.
  opts.on('--include PATTERN',
          'Include methods matching PATTERN; if PATTERN looks like a path, includes files instead') do |v|
    if looks_like_file_pattern?(v)
      options[:include_file] << v
    else
      options[:include] << v
    end
  end
  opts.on('--exclude PATTERN',
          'Exclude methods matching PATTERN; if PATTERN looks like a path, excludes files instead') do |v|
    if looks_like_file_pattern?(v)
      options[:exclude_file] << v
    else
      options[:exclude] << v
    end
  end
  opts.on('--include-file PATTERN', 'Only process files matching PATTERN (glob or /regex/)') do |v|
    options[:include_file] << v
  end

  opts.on('--exclude-file PATTERN', 'Skip files matching PATTERN (glob or /regex/). Exclude wins.') do |v|
    options[:exclude_file] << v
  end
  opts.on('-v', '--version', 'Print version and exit') do
    require 'docscribe/version'
    puts Docscribe::VERSION
    exit
  end
  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end
end

parser.parse!(ARGV)

conf = Docscribe::Config.load(options[:config])

if options[:include]&.any? || options[:exclude]&.any? || options[:include_file]&.any? || options[:exclude_file]&.any?
  raw = Marshal.load(Marshal.dump(conf.raw)) # deep dup (drop-in, works fine)
  raw['filter'] ||= {}

  # method filters
  raw['filter']['include'] = Array(raw['filter']['include']) + options[:include]
  raw['filter']['exclude'] = Array(raw['filter']['exclude']) + options[:exclude]

  # file filters
  raw['filter']['files'] ||= {}
  raw['filter']['files']['include'] = Array(raw['filter']['files']['include']) + options[:include_file]
  raw['filter']['files']['exclude'] = Array(raw['filter']['files']['exclude']) + options[:exclude_file]

  conf = Docscribe::Config.new(raw)
end

if options[:include]&.any? || options[:exclude]&.any?
  raw = Marshal.load(Marshal.dump(conf.raw)) # deep dup, simplest drop-in
  raw['filter'] ||= {}
  raw['filter']['include'] = Array(raw['filter']['include']) + options[:include]
  raw['filter']['exclude'] = Array(raw['filter']['exclude']) + options[:exclude]
  conf = Docscribe::Config.new(raw)
end

require 'docscribe/inline_rewriter'

def transform(code, replace:, config:)
  Docscribe::InlineRewriter.insert_comments(code, rewrite: replace, config: config)
end

def rewrite(code, replace:)
  Docscribe::InlineRewriter.insert_comments(code, rewrite: replace)
end

def expand_paths(args)
  files = []

  args.each do |path|
    if File.directory?(path)
      files.concat(Dir.glob(File.join(path, '**', '*.rb')))
    elsif File.file?(path)
      files << path
    else
      warn "Skipping missing path: #{path}"
    end
  end

  files.uniq.sort
end

if options[:stdin]
  code = $stdin.read
  puts rewrite(code, replace: options[:refresh])
  exit 0
end

if ARGV.empty?
  warn 'No input. Use --stdin or pass file paths. See --help.'
  exit 1
end

$stdout.sync = true

paths = expand_paths(ARGV)
paths = paths.select { |p| conf.process_file?(p) }
if paths.empty?
  warn 'No files found. Pass files or directories (e.g. `docscribe --dry lib`).'
  exit 1
end

changed = false
checked_ok = 0
checked_fail = 0
corrected = 0
fail_paths = []

paths.each do |path|
  src = File.read(path)
  out = transform(src, replace: options[:refresh], config: conf)

  if options[:check]
    if out == src
      print '.'
      checked_ok += 1
    else
      print 'F'
      checked_fail += 1
      changed = true
      fail_paths << path
    end

  elsif options[:write]
    if out == src
      print '.'
    else
      File.write(path, out)
      print 'C'
      corrected += 1
    end

  else
    warn 'No mode selected. Use --dry, --write, or --stdin. See --help.'
    exit 1
  end
end

if options[:check]
  puts
  if checked_fail.zero?
    puts "Docscribe: OK (#{checked_ok} files checked)"
  else
    puts "Docscribe: FAILED (#{checked_fail} failing, #{checked_ok} ok)"
    fail_paths.each { |p| warn "Missing docs: #{p}" }
  end
elsif options[:write]
  puts
  puts "Docscribe: updated #{corrected} file(s)" if corrected.positive?
end

exit(options[:check] && changed ? 1 : 0)
