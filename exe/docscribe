#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'docscribe/config'
require 'docscribe/inline_rewriter'

options = {
  stdin: false,
  write: false, # rewrite files in place
  check: false, # dry-run (exit 1 if any file would change)
  rewrite: false, # replace existing comment blocks when inserting
  config: nil
}

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: docscribe [options] [files...]'
  opts.on('--stdin', 'Read code from STDIN and print with docs inserted') { options[:stdin] = true }
  opts.on('--write', 'Rewrite files in place') { options[:write] = true }
  opts.on('--check', 'Dry-run: exit 1 if any file would change') { options[:check] = true }
  opts.on('--rewrite', 'Replace existing comment blocks above methods') { options[:rewrite] = true }
  opts.on('--config PATH', 'Path to config YAML (default: docscribe.yml)') { |v| options[:config] = v }
  opts.on('--version', 'Print version and exit') do
    require 'docscribe/version'
    puts Docscribe::VERSION
    exit
  end
  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end
end

parser.parse!(ARGV)

conf = Docscribe::Config.load(options[:config])

def transform(code, replace:, config:)
  Docscribe::InlineRewriter.insert_comments(code, rewrite: replace, config: config)
end

def rewrite(code, replace:)
  Docscribe::InlineRewriter.insert_comments(code, rewrite: replace)
end

def expand_paths(args)
  files = []

  args.each do |path|
    if File.directory?(path)
      files.concat(Dir.glob(File.join(path, '**', '*.rb')))
    elsif File.file?(path)
      files << path
    else
      warn "Skipping missing path: #{path}"
    end
  end

  files.uniq.sort
end

if options[:stdin]
  code = $stdin.read
  puts rewrite(code, replace: options[:rewrite])
  exit 0
end

if ARGV.empty?
  warn 'No input. Use --stdin or pass file paths. See --help.'
  exit 1
end

$stdout.sync = true

paths = expand_paths(ARGV)
if paths.empty?
  warn 'No files found. Pass files or directories (e.g. `docscribe --check lib`).'
  exit 1
end

changed = false
checked_ok = 0
checked_fail = 0
corrected = 0
fail_paths = []

paths.each do |path|
  src = File.read(path)
  out = transform(src, replace: options[:rewrite], config: conf)

  if options[:check]
    if out == src
      print '.'
      checked_ok += 1
    else
      print 'F'
      checked_fail += 1
      changed = true
      fail_paths << path
    end

  elsif options[:write]
    if out == src
      print '.'
    else
      File.write(path, out)
      print 'C'
      corrected += 1
    end

  else
    puts out
  end
end

if options[:check]
  puts
  if checked_fail.zero?
    puts "Docscribe: OK (#{checked_ok} files checked)"
  else
    puts "Docscribe: FAILED (#{checked_fail} failing, #{checked_ok} ok)"
    fail_paths.each { |p| warn "Missing docs: #{p}" }
  end
elsif options[:write]
  puts
  puts "Docscribe: updated #{corrected} file(s)" if corrected.positive?
end

exit(options[:check] && changed ? 1 : 0)
